{
  "version": 3,
  "sources": ["../../ajv-errors/src/index.ts"],
  "sourcesContent": ["import type {Plugin, CodeKeywordDefinition, KeywordCxt, ErrorObject, Code} from \"ajv\"\nimport Ajv, {_, str, stringify, Name} from \"ajv\"\nimport {and, or, not, strConcat} from \"ajv/dist/compile/codegen\"\nimport {safeStringify, _Code} from \"ajv/dist/compile/codegen/code\"\nimport {getData} from \"ajv/dist/compile/validate\"\nimport {reportError} from \"ajv/dist/compile/errors\"\nimport N from \"ajv/dist/compile/names\"\n\ntype ErrorsMap<T extends string | number> = {[P in T]?: ErrorObject[]}\n\ntype StringMap = {[P in string]?: string}\n\ntype ErrorMessageSchema = {\n  properties?: StringMap\n  items?: string[]\n  required?: string | StringMap\n  dependencies?: string | StringMap\n  _?: string\n} & {[K in string]?: string | StringMap}\n\ninterface ChildErrors {\n  props?: ErrorsMap<string>\n  items?: ErrorsMap<number>\n}\n\nconst keyword = \"errorMessage\"\n\nconst used: Name = new Name(\"emUsed\")\n\nconst KEYWORD_PROPERTY_PARAMS = {\n  required: \"missingProperty\",\n  dependencies: \"property\",\n  dependentRequired: \"property\",\n}\n\nexport interface ErrorMessageOptions {\n  keepErrors?: boolean\n  singleError?: boolean | string\n}\n\nconst INTERPOLATION = /\\$\\{[^}]+\\}/\nconst INTERPOLATION_REPLACE = /\\$\\{([^}]+)\\}/g\nconst EMPTY_STR = /^\"\"\\s*\\+\\s*|\\s*\\+\\s*\"\"$/g\n\nfunction errorMessage(options: ErrorMessageOptions): CodeKeywordDefinition {\n  return {\n    keyword,\n    schemaType: [\"string\", \"object\"],\n    post: true,\n    code(cxt: KeywordCxt) {\n      const {gen, data, schema, schemaValue, it} = cxt\n      if (it.createErrors === false) return\n      const sch: ErrorMessageSchema | string = schema\n      const instancePath = strConcat(N.instancePath, it.errorPath)\n      gen.if(_`${N.errors} > 0`, () => {\n        if (typeof sch == \"object\") {\n          const [kwdPropErrors, kwdErrors] = keywordErrorsConfig(sch)\n          if (kwdErrors) processKeywordErrors(kwdErrors)\n          if (kwdPropErrors) processKeywordPropErrors(kwdPropErrors)\n          processChildErrors(childErrorsConfig(sch))\n        }\n        const schMessage = typeof sch == \"string\" ? sch : sch._\n        if (schMessage) processAllErrors(schMessage)\n        if (!options.keepErrors) removeUsedErrors()\n      })\n\n      function childErrorsConfig({properties, items}: ErrorMessageSchema): ChildErrors {\n        const errors: ChildErrors = {}\n        if (properties) {\n          errors.props = {}\n          for (const p in properties) errors.props[p] = []\n        }\n        if (items) {\n          errors.items = {}\n          for (let i = 0; i < items.length; i++) errors.items[i] = []\n        }\n        return errors\n      }\n\n      function keywordErrorsConfig(\n        emSchema: ErrorMessageSchema\n      ): [{[K in string]?: ErrorsMap<string>} | undefined, ErrorsMap<string> | undefined] {\n        let propErrors: {[K in string]?: ErrorsMap<string>} | undefined\n        let errors: ErrorsMap<string> | undefined\n\n        for (const k in emSchema) {\n          if (k === \"properties\" || k === \"items\") continue\n          const kwdSch = emSchema[k]\n          if (typeof kwdSch == \"object\") {\n            propErrors ||= {}\n            const errMap: ErrorsMap<string> = (propErrors[k] = {})\n            for (const p in kwdSch) errMap[p] = []\n          } else {\n            errors ||= {}\n            errors[k] = []\n          }\n        }\n        return [propErrors, errors]\n      }\n\n      function processKeywordErrors(kwdErrors: ErrorsMap<string>): void {\n        const kwdErrs = gen.const(\"emErrors\", stringify(kwdErrors))\n        const templates = gen.const(\"templates\", getTemplatesCode(kwdErrors, schema))\n        gen.forOf(\"err\", N.vErrors, (err) =>\n          gen.if(matchKeywordError(err, kwdErrs), () =>\n            gen.code(_`${kwdErrs}[${err}.keyword].push(${err})`).assign(_`${err}.${used}`, true)\n          )\n        )\n        const {singleError} = options\n        if (singleError) {\n          const message = gen.let(\"message\", _`\"\"`)\n          const paramsErrors = gen.let(\"paramsErrors\", _`[]`)\n          loopErrors((key) => {\n            gen.if(message, () =>\n              gen.code(_`${message} += ${typeof singleError == \"string\" ? singleError : \";\"}`)\n            )\n            gen.code(_`${message} += ${errMessage(key)}`)\n            gen.assign(paramsErrors, _`${paramsErrors}.concat(${kwdErrs}[${key}])`)\n          })\n          reportError(cxt, {message, params: _`{errors: ${paramsErrors}}`})\n        } else {\n          loopErrors((key) =>\n            reportError(cxt, {\n              message: errMessage(key),\n              params: _`{errors: ${kwdErrs}[${key}]}`,\n            })\n          )\n        }\n\n        function loopErrors(body: (key: Name) => void): void {\n          gen.forIn(\"key\", kwdErrs, (key) => gen.if(_`${kwdErrs}[${key}].length`, () => body(key)))\n        }\n\n        function errMessage(key: Name): Code {\n          return _`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}[${key}]`\n        }\n      }\n\n      function processKeywordPropErrors(kwdPropErrors: {[K in string]?: ErrorsMap<string>}): void {\n        const kwdErrs = gen.const(\"emErrors\", stringify(kwdPropErrors))\n        const templatesCode: [string, Code][] = []\n        for (const k in kwdPropErrors) {\n          templatesCode.push([\n            k,\n            getTemplatesCode(kwdPropErrors[k] as ErrorsMap<string>, schema[k]),\n          ])\n        }\n        const templates = gen.const(\"templates\", gen.object(...templatesCode))\n\n        const kwdPropParams = gen.scopeValue(\"obj\", {\n          ref: KEYWORD_PROPERTY_PARAMS,\n          code: stringify(KEYWORD_PROPERTY_PARAMS),\n        })\n        const propParam = gen.let(\"emPropParams\")\n        const paramsErrors = gen.let(\"emParamsErrors\")\n\n        gen.forOf(\"err\", N.vErrors, (err) =>\n          gen.if(matchKeywordError(err, kwdErrs), () => {\n            gen.assign(propParam, _`${kwdPropParams}[${err}.keyword]`)\n            gen.assign(paramsErrors, _`${kwdErrs}[${err}.keyword][${err}.params[${propParam}]]`)\n            gen.if(paramsErrors, () =>\n              gen.code(_`${paramsErrors}.push(${err})`).assign(_`${err}.${used}`, true)\n            )\n          })\n        )\n\n        gen.forIn(\"key\", kwdErrs, (key) =>\n          gen.forIn(\"keyProp\", _`${kwdErrs}[${key}]`, (keyProp) => {\n            gen.assign(paramsErrors, _`${kwdErrs}[${key}][${keyProp}]`)\n            gen.if(_`${paramsErrors}.length`, () => {\n              const tmpl = gen.const(\n                \"tmpl\",\n                _`${templates}[${key}] && ${templates}[${key}][${keyProp}]`\n              )\n              reportError(cxt, {\n                message: _`${tmpl} ? ${tmpl}() : ${schemaValue}[${key}][${keyProp}]`,\n                params: _`{errors: ${paramsErrors}}`,\n              })\n            })\n          })\n        )\n      }\n\n      function processChildErrors(childErrors: ChildErrors): void {\n        const {props, items} = childErrors\n        if (!props && !items) return\n        const isObj = _`typeof ${data} == \"object\"`\n        const isArr = _`Array.isArray(${data})`\n        const childErrs = gen.let(\"emErrors\")\n        let childKwd: Name\n        let childProp: Code\n        const templates = gen.let(\"templates\")\n        if (props && items) {\n          childKwd = gen.let(\"emChildKwd\")\n          gen.if(isObj)\n          gen.if(\n            isArr,\n            () => {\n              init(items, schema.items)\n              gen.assign(childKwd, str`items`)\n            },\n            () => {\n              init(props, schema.properties)\n              gen.assign(childKwd, str`properties`)\n            }\n          )\n          childProp = _`[${childKwd}]`\n        } else if (items) {\n          gen.if(isArr)\n          init(items, schema.items)\n          childProp = _`.items`\n        } else if (props) {\n          gen.if(and(isObj, not(isArr)))\n          init(props, schema.properties)\n          childProp = _`.properties`\n        }\n\n        gen.forOf(\"err\", N.vErrors, (err) =>\n          ifMatchesChildError(err, childErrs, (child) =>\n            gen.code(_`${childErrs}[${child}].push(${err})`).assign(_`${err}.${used}`, true)\n          )\n        )\n\n        gen.forIn(\"key\", childErrs, (key) =>\n          gen.if(_`${childErrs}[${key}].length`, () => {\n            reportError(cxt, {\n              message: _`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}${childProp}[${key}]`,\n              params: _`{errors: ${childErrs}[${key}]}`,\n            })\n            gen.assign(\n              _`${N.vErrors}[${N.errors}-1].instancePath`,\n              _`${instancePath} + \"/\" + ${key}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`\n            )\n          })\n        )\n\n        gen.endIf()\n\n        function init<T extends string | number>(\n          children: ErrorsMap<T>,\n          msgs: {[K in string]?: string}\n        ): void {\n          gen.assign(childErrs, stringify(children))\n          gen.assign(templates, getTemplatesCode(children, msgs))\n        }\n      }\n\n      function processAllErrors(schMessage: string): void {\n        const errs = gen.const(\"emErrs\", _`[]`)\n        gen.forOf(\"err\", N.vErrors, (err) =>\n          gen.if(matchAnyError(err), () =>\n            gen.code(_`${errs}.push(${err})`).assign(_`${err}.${used}`, true)\n          )\n        )\n        gen.if(_`${errs}.length`, () =>\n          reportError(cxt, {\n            message: templateExpr(schMessage),\n            params: _`{errors: ${errs}}`,\n          })\n        )\n      }\n\n      function removeUsedErrors(): void {\n        const errs = gen.const(\"emErrs\", _`[]`)\n        gen.forOf(\"err\", N.vErrors, (err) =>\n          gen.if(_`!${err}.${used}`, () => gen.code(_`${errs}.push(${err})`))\n        )\n        gen.assign(N.vErrors, errs).assign(N.errors, _`${errs}.length`)\n      }\n\n      function matchKeywordError(err: Name, kwdErrs: Name): Code {\n        return and(\n          _`${err}.keyword !== ${keyword}`,\n          _`!${err}.${used}`,\n          _`${err}.instancePath === ${instancePath}`,\n          _`${err}.keyword in ${kwdErrs}`,\n          // TODO match the end of the string?\n          _`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`,\n          _`/^\\\\/[^\\\\/]*$/.test(${err}.schemaPath.slice(${it.errSchemaPath.length}))`\n        )\n      }\n\n      function ifMatchesChildError(\n        err: Name,\n        childErrs: Name,\n        thenBody: (child: Name) => void\n      ): void {\n        gen.if(\n          and(\n            _`${err}.keyword !== ${keyword}`,\n            _`!${err}.${used}`,\n            _`${err}.instancePath.indexOf(${instancePath}) === 0`\n          ),\n          () => {\n            const childRegex = gen.scopeValue(\"pattern\", {\n              ref: /^\\/([^/]*)(?:\\/|$)/,\n              code: _`new RegExp(\"^\\\\\\/([^/]*)(?:\\\\\\/|$)\")`,\n            })\n            const matches = gen.const(\n              \"emMatches\",\n              _`${childRegex}.exec(${err}.instancePath.slice(${instancePath}.length))`\n            )\n            const child = gen.const(\n              \"emChild\",\n              _`${matches} && ${matches}[1].replace(/~1/g, \"/\").replace(/~0/g, \"~\")`\n            )\n            gen.if(_`${child} !== undefined && ${child} in ${childErrs}`, () => thenBody(child))\n          }\n        )\n      }\n\n      function matchAnyError(err: Name): Code {\n        return and(\n          _`${err}.keyword !== ${keyword}`,\n          _`!${err}.${used}`,\n          or(\n            _`${err}.instancePath === ${instancePath}`,\n            and(\n              _`${err}.instancePath.indexOf(${instancePath}) === 0`,\n              _`${err}.instancePath[${instancePath}.length] === \"/\"`\n            )\n          ),\n          _`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`,\n          _`${err}.schemaPath[${it.errSchemaPath}.length] === \"/\"`\n        )\n      }\n\n      function getTemplatesCode(keys: Record<string, any>, msgs: {[K in string]?: string}): Code {\n        const templatesCode: [string, Code][] = []\n        for (const k in keys) {\n          const msg = msgs[k] as string\n          if (INTERPOLATION.test(msg)) templatesCode.push([k, templateFunc(msg)])\n        }\n        return gen.object(...templatesCode)\n      }\n\n      function templateExpr(msg: string): Code {\n        if (!INTERPOLATION.test(msg)) return stringify(msg)\n        return new _Code(\n          safeStringify(msg)\n            .replace(\n              INTERPOLATION_REPLACE,\n              (_s, ptr) => `\" + JSON.stringify(${getData(ptr, it)}) + \"`\n            )\n            .replace(EMPTY_STR, \"\")\n        )\n      }\n\n      function templateFunc(msg: string): Code {\n        return _`function(){return ${templateExpr(msg)}}`\n      }\n    },\n    metaSchema: {\n      anyOf: [\n        {type: \"string\"},\n        {\n          type: \"object\",\n          properties: {\n            properties: {$ref: \"#/$defs/stringMap\"},\n            items: {$ref: \"#/$defs/stringList\"},\n            required: {$ref: \"#/$defs/stringOrMap\"},\n            dependencies: {$ref: \"#/$defs/stringOrMap\"},\n          },\n          additionalProperties: {type: \"string\"},\n        },\n      ],\n      $defs: {\n        stringMap: {\n          type: \"object\",\n          additionalProperties: {type: \"string\"},\n        },\n        stringOrMap: {\n          anyOf: [{type: \"string\"}, {$ref: \"#/$defs/stringMap\"}],\n        },\n        stringList: {type: \"array\", items: {type: \"string\"}},\n      },\n    },\n  }\n}\n\nconst ajvErrors: Plugin<ErrorMessageOptions> = (\n  ajv: Ajv,\n  options: ErrorMessageOptions = {}\n): Ajv => {\n  if (!ajv.opts.allErrors) throw new Error(\"ajv-errors: Ajv option allErrors must be true\")\n  if (ajv.opts.jsPropertySyntax) {\n    throw new Error(\"ajv-errors: ajv option jsPropertySyntax is not supported\")\n  }\n  return ajv.addKeyword(errorMessage(options))\n}\n\nexport default ajvErrors\nmodule.exports = ajvErrors\nmodule.exports.default = ajvErrors\n"],
  "mappings": "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",
  "names": []
}
